/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "GestorJuegos.h"
#include <stdbool.h>
#include <time.h>

typedef struct 
{
 int Codigo; 		  //Código del juego
 char Tablero[9][9];      //Tablero de juego
 TDificultad Dificultad;  //Dificultad
} TJuego;


TJuego *Sudokus=NULL;   //Vector dinámico de Juegos
int NSudokus=0; 	//Número de juegos almacenados en el vector Sudokus
int codigoSudoku=0;


int buscarSudoku(int codigo) {
	int i = 0;
	int pos = 0;
	bool encontrado = false;
	
	while(i < NSudokus && !encontrado) {
		if(Sudokus[i].Codigo == codigo) {
			encontrado =  true;
		} else {
			i++;
		}	
	}
	if(encontrado) {
		pos = i;
	} else {
		pos = -1;
	}
	return pos;
}

int generarCodigosSudoku() {
	
	codigoSudoku++;
	return codigoSudoku;
}

//Método que inicializa el atributo Dificultad con pDifi y el Tablero con el carácter ' '
int Inicializar(TDificultad pDifi, int pos) {	
	int resultado;
	if (pos == -1) {
		printf("El sudoku no existe\n");
		resultado = 0;	
	} else {
		Sudokus[pos].Dificultad=pDifi;		
		for (int f = 0; f < 9; f++) {
			for (int c = 0; c < 9; c++) {
				Sudokus[pos].Tablero[f][c] = ' ';
			}
		}
		resultado = 1; 	
	}
	return resultado;			
}

//Método que devuelve el número de ocurrencias del carácter pVal en la fila pFil.
//La salida podrá ser 0 = Ninguna ocurrencia, 1=Una ocurrencia, 2=dos o más ocurrencias.
int BuscarPorFila(int pFil, char pVal, int pos) {
	int Cuantos = 0;
    	for (int c = 0; c < 9 && Cuantos < 2; c++)
        	if (Sudokus[pos].Tablero[pFil][c] == pVal)
            		Cuantos++;
    	return Cuantos;
}

//Método que devuelve el número de ocurrencias del caracter pval, en la columna pCol.
int BuscarPorColumna(int pCol, char pVal, int pos) {
	int Cuantos = 0;
    	for (int f = 0; f < 9 && Cuantos < 2; f++)
        	if (Sudokus[pos].Tablero[f][pCol] == pVal)
            		Cuantos++;
    	return Cuantos;
}

//Método que devuelve el número de ocurrencias del caracter pval, en bloque del juego que
//contiene la fila pfil y la columna pCol.
int BuscarPorBloque(int pFil, int pCol, char pVal, int pos) {
	int minF = (pFil / 3) * 3;
	int minC = (pCol / 3) * 3;
	int maxF = minF + 3;
        int maxC = minC + 3;

        int Cuantos = 0;
        for (int f = minF; f < maxF && Cuantos < 2; f++)
        	for (int c = minC; c < maxC && Cuantos < 2; c++)
            		if (Sudokus[pos].Tablero[f][c] == pVal)
                		Cuantos++;
        return Cuantos;
}

bool ponervalor(TFCV *argp, int pos) {
	bool resultado = false;
	if (pos == -1) {
		resultado = false;
	}
	else {
		Sudokus[pos].Tablero[argp->pFil][argp->pCol] = argp->pVal;
		resultado = true;
	}		
	return resultado;
}

char obtenervalor(TFCV *argp, int pos) {
	char result;
	if (pos == -1) {
		result = ' ';
	}
	else
		result=Sudokus[pos].Tablero[argp->pFil][argp->pCol];
	return result;
}

bool comprobarvalor(TFCV *argp, int pos) {
	bool result = true;
	if (pos == -1) {
		result = false;
	}
    	if (BuscarPorFila(argp->pFil, argp->pVal, pos) != 1 || BuscarPorColumna(argp->pCol, argp->pVal, pos) != 1 || BuscarPorBloque(argp->pFil, argp->pCol, argp->pVal, pos) != 1)
        	result = false;

	return result;
}

bool ponervalor2(TFC *argp, char valor, int pos) {
	int resultado = false;
	if (pos == -1) {
		resultado = false;
	}
	else {
		Sudokus[pos].Tablero[argp->pFil][argp->pCol] = valor;
		resultado = true;
	}
	return resultado;		
}

char obtenervalor2(TFC *argp, int pos) {
	char result;
	if (pos == -1) {
		result = ' ';
	}
	else
		result=Sudokus[pos].Tablero[argp->pFil][argp->pCol];
	
	return result;
}

bool comprobarvalor2(TFC *argp, char valor, int pos) {
	bool result = true;
	if (pos == -1) {
		result = false;
	}
    	if (BuscarPorFila(argp->pFil, valor, pos) != 1 || BuscarPorColumna(argp->pCol, valor, pos) != 1 || BuscarPorBloque(argp->pFil, argp->pCol, valor, pos) != 1)
        	result = false;

	return result;
}

int numerohuecos(int pos)
{
	int result;
	result = 0;
    	for (int f = 0; f < 9; f++)
        	for (int c = 0; c < 9; c++)
            		if (Sudokus[pos].Tablero[f][c] == ' ')
                		result++;

	return result;
}

int *
nuevo_1_svc(TDificultad *argp, struct svc_req *rqstp)
{
	static int result;
	int f, c, posicion;
    	char Valor;
	TJuego Sudoku;
	
	TFCV *estructuraTFCV = (TFCV*) malloc (sizeof(TFCV));
	Sudokus = (TJuego*) malloc (10*sizeof(TJuego));

	if (estructuraTFCV == NULL || Sudokus == NULL) {
		printf("Error al reservar memoria\n");
	}
	else {
		estructuraTFCV->pFil = 0;
		estructuraTFCV->pCol = 0;
		estructuraTFCV->pVal = ' ';
		Sudoku.Codigo = generarCodigosSudoku();
		estructuraTFCV->pCod = Sudoku.Codigo;
		printf("El valor del codigo del sudoku es: %d\n", Sudoku.Codigo);
		
		Sudokus[NSudokus]=Sudoku;      					
		NSudokus++;		
		
		posicion = buscarSudoku(Sudoku.Codigo);
		printf("La posicion del sudoku creado es: %d\n", posicion);

    		bool inicializar = Inicializar(*argp, posicion);
		if(!inicializar) {
			printf("Error al crear el sudoku\n");
		} else {
			char ValoresActuales[81];
	    		srand(time(0));
		
	    		for (int i = 0; i < 81; i++)
				ValoresActuales[i] = ' ';

	    		int Pos;
	    		for (char v = '1'; v <= '9'; v++)
	    		{
				Pos = rand()%9;
				while (ValoresActuales[Pos] != ' ')
				{
					Pos++;
					if (Pos == 9)
						Pos = 0;
				}
				ValoresActuales[Pos] = v;
				estructuraTFCV->pFil = 0;
				estructuraTFCV->pCol = Pos;
				estructuraTFCV->pVal = v;
				ponervalor(estructuraTFCV, posicion);
	    		}
	
	    		Pos = 9;
	    		while (Pos < 81)
	    		{
				f = Pos / 9;
				c = Pos % 9;
				Valor = ValoresActuales[Pos] != ' ' ? ValoresActuales[Pos] : '0';

				bool EsCorrecto = false;
				while (EsCorrecto == false && Valor < '9')
				{
		    			Valor++;
					estructuraTFCV->pFil = f;
					estructuraTFCV->pCol = c;
					estructuraTFCV->pVal = Valor;
		    			ponervalor(estructuraTFCV, posicion);
		    			EsCorrecto = comprobarvalor(estructuraTFCV, posicion);
				};

				if (EsCorrecto == true)
				{
		    			ValoresActuales[Pos] = Valor;
		    			Pos++;
				}
				else
				{
		    			ValoresActuales[Pos] = ' ';
					estructuraTFCV->pVal = ' ';
		    			ponervalor(estructuraTFCV, posicion);
		    			Pos--;
				}
	    		}
			
	    		int NHuecos = 0;
	    		switch (*argp)
	    		{
	    			case MUY_FACIL:
					NHuecos = 10;
					break;
	    			case FACIL:
					NHuecos = 30;
					break;
				case DIFICIL:
					NHuecos = 60;
					break;
				case MUY_DIFICIL:
					NHuecos = 70;
					break;
				default:
					NHuecos = 40;
			};
			
	    		for (int i = 0; i < NHuecos; i++)
	    		{
				do
				{	
		    			f = rand()%9;
		    			c = rand()%9;
					estructuraTFCV->pFil = f;
	    				estructuraTFCV->pCol = c;
				}
				while (obtenervalor(estructuraTFCV, posicion) == ' ');
				estructuraTFCV->pFil = f;
	    			estructuraTFCV->pCol = c;
	    			estructuraTFCV->pVal = ' ';
				ponervalor(estructuraTFCV, posicion);			
	    		}		
		} 
		result = Sudoku.Codigo; 		
	}	
	free(estructuraTFCV);	
	printf("El valor del codigo del sudoku antes de devolverlo es: %d\n", Sudoku.Codigo);
	return &result;
}

bool_t *
borrar_1_svc(int *argp, struct svc_req *rqstp)
{
	static bool_t  result;
	int pos = buscarSudoku(*argp);
	int r = Inicializar(VACIO, pos);
	if(r == 0) {
		result = false;		
	} else {
		result = true;
	} 
	return &result;
}

bool_t *
ponervalor_1_svc(TFCV *argp, struct svc_req *rqstp)
{
	static bool_t  result;
	int pos = buscarSudoku(argp->pCod);
	result = ponervalor(argp, pos);
	if(!result) {
		printf("Error al poner el valor\n");
	}
	return &result;
}

char *
obtenervalor_1_svc(TFC *argp, struct svc_req *rqstp)
{
	static char  result;
	int pos = buscarSudoku(argp->pCod);
	result = obtenervalor2(argp, pos);
	
	return &result;
}

bool_t *
comprobarvalor_1_svc(TFCV *argp, struct svc_req *rqstp)
{
	static bool_t  result = true;
	int pos = buscarSudoku(argp->pCod);
	if (pos == -1) {
		result = false;
	}
	else {
		if (BuscarPorFila(argp->pFil, argp->pVal, pos) != 1 || BuscarPorColumna(argp->pCol, argp->pVal, pos) != 1 || BuscarPorBloque(argp->pFil, argp->pCol, argp->pVal, pos) != 1)
        		result = false;
	}
	return &result;
}

int *
numerohuecos_1_svc(int *argp, struct svc_req *rqstp)
{
	static int  result;
	int pos = buscarSudoku(*argp);
	if (pos == -1) {
		result = -1;
	} else {
		result = 0;
    		for (int f = 0; f < 9; f++)
        		for (int c = 0; c < 9; c++)
            			if (Sudokus[pos].Tablero[f][c] == ' ')
                			result++;
	}
	return &result;
	
}

bool_t *
correcto_1_svc(int *argp, struct svc_req *rqstp)
{
	static bool_t  result = true;
	char Valor = '1';
    	int f, c;
	int pos = buscarSudoku(*argp);
	if (pos == -1) {
		result = false;
	} else {
		while (Valor <= '9' && result == true)
	    	{
			c = 0;
			while (c < 9 && result == true)
			{
		    		if (BuscarPorColumna(c, Valor, pos) != 1)
		    		{
		        		result = false;
		    		}
				c++;
		    	}	
		
			f = 0;
			while (f < 9 && result == true)
			{
		    		if (BuscarPorFila(f, Valor, pos) != 1)
		    		{
		        		result = false;
		    		}
		    		f++;
			}

			for (f = 0; f < 9 && result == true; f += 3)
			{
		    		for (c = 0; c < 9 && result == true; c += 3)
		    		{
		        		if (BuscarPorBloque(f, c, Valor, pos) != 1)
		        		{
		            			result = false;
		        		}
		    		}
			}
			Valor++;
	    	}
	}   	
	return &result;
}

RCadena *
ayuda_1_svc(TFC *argp, struct svc_req *rqstp)
{
	static RCadena result;
	char Valor;
    	int Pos=0;

	int posicion = buscarSudoku(argp->pCod);
    	strcpy(result.Contenido," ");
    	char v = obtenervalor2(argp, posicion);
    	if (v == ' ')
    	{
        	Valor = '1';
        	while (Valor <= '9')
        	{
            		ponervalor2(argp, Valor, posicion);
            		if (comprobarvalor2(argp, Valor, posicion) == true)
            		{
                		result.Contenido[Pos++] = Valor;
                		result.Contenido[Pos++] = ' ';
            		}		
            		Valor++;
        	}
        	ponervalor2(argp, ' ', posicion);
        	result.Contenido[Pos++]='\0';
		printf("El contenido de result.Contenido es: %s\n", result.Contenido);
    	} 
	return &result;
}

RCadena *
getsudoku_1_svc(int *argp, struct svc_req *rqstp)
{
	static RCadena  result;
	int pos = buscarSudoku(*argp); 
	
	Cadena Numero, pSudo;
	TFC *estructuraTFC = (TFC*) malloc (sizeof(TFC));

	if (estructuraTFC == NULL) {
		printf("Error al reservar memoria\n");
		strcpy(result.Contenido, "Error al reservar memoria.");
		return &result;
	} else {
		strcpy(pSudo,"Dificultad: ");
		if(pos == -1) {
			strcat(pSudo, "Vacio");
		} else {
			switch (Sudokus[pos].Dificultad)
			{
		    		case MUY_FACIL:
					strcat(pSudo,"Muy Fácil");
					break;
		    		case FACIL:
					strcat(pSudo,"Fácil");
					break;
		    		case MEDIA:
					strcat(pSudo,"Media");
					break;
		    		case DIFICIL:
					strcat(pSudo,"Difícil");
					break;
		    		case MUY_DIFICIL:
					strcat(pSudo,"Muy Difícil");
					break;
		    		default:
					strcat(pSudo,"** Sudoku vacío **");
		 	}
		}
		if (pos == -1) {
			sprintf(Numero,"%d",81);
		} else {
			sprintf(Numero,"%d",numerohuecos(pos));		
		}
			strcat(pSudo, "\tHuecos: ");
			strcat(pSudo,Numero);
			strcat(pSudo,"\n  123 456 789\n");
			for (int f = 0; f < 9; f++)
			{
				if (f % 3 == 0)
				    	strcat(pSudo," +---+---+---+\n");

				sprintf(Numero,"%d",f+1);
				strcat(pSudo,Numero);
				for (int c = 0; c < 9; c++)
				{
				    	if (c % 3 == 0)
						strcat(pSudo,"|");
				    	estructuraTFC->pCod = *argp;
				    	estructuraTFC->pFil = f;
				    	estructuraTFC->pCol = c;
				    	sprintf(Numero,"%c",obtenervalor2(estructuraTFC, pos));
				    	strcat(pSudo,Numero);
				};
				strcat(pSudo,"|\n");
			 };
			 strcat(pSudo," +---+---+---+\n");
			 strcpy(result.Contenido, pSudo);
		
	}
	free(estructuraTFC);
	
	return &result;
}
